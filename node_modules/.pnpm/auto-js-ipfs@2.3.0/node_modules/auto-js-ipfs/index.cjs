'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* global Response, ReadableStream, FormData, Headers, Blob */
const W3S_LINK_URL = 'https://w3s.link/';
const DEFAULT_GATEWAY = W3S_LINK_URL;

function parseIPFSURL (url) {
  const { hostname, protocol, pathname } = new URL(url);

  const type = protocol.slice(0, -1);

  if (!hostname) {
    const [cid, ...segments] = pathname.slice(2).split('/');
    const path = '/' + segments.join('/');
    return { type, cid, path }
  }
  return { type, cid: hostname, path: pathname }
}

// Might not convert if it's a plain string
// Used for appending to form data
async function autoBlob (content) {
  if (isStream(content)) {
    const blob = await streamToBlob(content);
    return blob
  } else if (isIterator(content)) {
    const stream = iteratorToStream(content);
    const blob = await streamToBlob(stream);
    return blob
  } else if (content instanceof Blob) {
    return content
  } else {
    return new Blob([content])
  }
}

async function autoStream (content) {
  if (isStream(content)) return content
  if (isIterator(content)) return iteratorToStream(content)
  /* if (typeof content.stream === 'function') {
    // Probably a Blob or a File
    return content.stream()
  } */
  // Probably a string or something
  return content
}

async function streamToBlob (stream) {
  const response = new Response(stream);
  return response.blob()
}

async function * streamToIterator (stream) {
  const reader = await stream.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) return
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}

function iteratorToStream (iterable) {
  let iterator = iterable;
  if (!iterator.next) {
    iterator = iterable[Symbol.asyncIterator]();
  }
  const encoder = new TextEncoder();
  return new ReadableStream({
    async pull (controller) {
      const { value, done } = await iterator.next();

      if (done) {
        await controller.close();
      } else {
        let toSend = value;
        if (typeof toSend === 'string') {
          toSend = encoder.encode(toSend);
        }
        await controller.enqueue(toSend);
      }
    }
  })
}

async function checkError (response) {
  if (!response.ok) {
    const error = await response.text();
    const status = response.status;
    throw new Error(`HTTP Error ${status}: ${error}`)
  }
}

async function postRawBody ({
  url,
  fileIterator,
  signal
}) {
  const headers = new Headers();

  headers.set('Content-Type', 'application/octet-stream');

  addAuthorizationHeader(url, headers);

  const body = await autoStream(fileIterator);

  const duplex = 'half';

  const response = await fetch(url, {
    method: 'POST',
    signal,
    body,
    headers,
    duplex
  });

  await checkError(response);

  return response
}

async function postFormFile ({
  url,
  file,
  fileName = '',
  parameterName = 'file',
  fetch = globalThis.fetch,
  signal
}) {
  const body = new FormData();
  const headers = new Headers();

  addAuthorizationHeader(url, headers);

  const content = await autoBlob(file);

  if (fileName) {
    body.append(parameterName, content, fileName);
  } else {
    body.append(parameterName, content);
  }

  const response = await fetch(url, {
    method: 'POST',
    body,
    headers,
    signal
  });

  await checkError(response);

  return response
}

function isStream (content) {
  return typeof content.getReader === 'function'
}

function isIterator (content) {
  return content[Symbol.asyncIterator]
  // || content[Symbol.iterator]
}

function addAuthorizationHeader (url, headers) {
  if (url.password) {
    if (url.username) {
      const encoded = btoa(`${unescape(url.username)}:${unescape(url.password)}`);
      const auth = `Basic ${encoded}`;
      headers.append('Authorization', unescape(auth));
      url.username = '';
      url.password = '';
    } else {
      // If we just have a password, it's for a bearer token
      const token = url.password;
      const auth = `Bearer ${token}`;
      headers.append('Authorization', unescape(auth));
      url.password = '';
    }
  }
}

async function getSizeFromURL ({
  url,
  fetch = globalThis.fetch,
  signal
}) {
  const response = await fetch(url, {
    method: 'HEAD',
    signal
  });

  await checkError(response);

  const lengthHeader = response.headers.get('x-ipfs-datasize') || response.headers.get('Content-Length');

  return parseInt(lengthHeader, 10)
}

async function * getFromURL ({
  url,
  start,
  end,
  format,
  signal,
  fetch = globalThis.fetch
}) {
  const headers = new Headers();
  if (Number.isInteger(start)) {
    if (Number.isInteger(end)) {
      headers.set('Range', `bytes=${start}-${end}`);
    } else {
      headers.set('Range', `bytes=${start}-`);
    }
  }

  const toFetch = new URL(url);

  if (format) {
    headers.set('Accept', `application/vnd.ipld.${format}`);
    headers.set('cache-control', 'no-cache');
  }

  const response = await fetch(toFetch.href, {
    headers,
    signal
  });

  await checkError(response);

  yield * streamToIterator(response.body);
}

function toGatewayURL (url, gatewayBaseURL = detectDefaultGateway()) {
  const { cid, path, type } = parseIPFSURL(url);

  const relative = `/${type}/${cid}${path}`;
  const toFetch = new URL(relative, gatewayBaseURL);

  return toFetch
}

async function * getFromGateway ({
  url,
  start,
  end,
  format,
  signal,
  gatewayURL = detectDefaultGateway()
}) {
  const toFetch = toGatewayURL(url, gatewayURL);

  yield * getFromURL({
    url: toFetch,
    start,
    end,
    format,
    signal
  });
}

function detectDefaultGateway () {
  if (!globalThis.location) return DEFAULT_GATEWAY
  const { pathname, hostname, protocol } = globalThis.location;
  const isOnGatewayPath = pathname.startsWith('/ipfs/') || pathname.startsWith('/ipns/');

  if (isOnGatewayPath) {
    return `${protocol}//${hostname}/`
  }

  const [subdomain, ...segments] = hostname.split('.');

  // If the first subdomain is about the length of a CID it's probably a gateway?
  const isGatewaySubdomain = subdomain.length === 59 && segments.length >= 2;

  if (isGatewaySubdomain) {
    return `${protocol}//${segments.join('.')}/`
  }

  return DEFAULT_GATEWAY
}

/* global fetch, Blob */

let debug = false;

function setDebug (shouldDebug = true) {
  debug = shouldDebug;
}

const KNOWN_DAEMON_PORTS = [5001, 45001, 45002, 45003, 45004, 45005];
const WEB3_STORAGE_URL = 'https://api.web3.storage/';
const ESTUARY_URL = 'https://api.estuary.tech/';
const DEFAULT_DAEMON_API_URL = 'http://localhost:5001/';
const DEFAULT_TIMEOUT = 1000;
const AGREGORE_TYPE = 'agregore';
const DAEMON_TYPE = 'daemon';
const PREFERRED_DAEMON_TYPE = 'daemon:preferred';
const WEB3_STORAGE_TYPE = 'web3.storage';
const ESTUARY_TYPE = 'estuary';
const READONLY_TYPE = 'readonly';
const INVALID_TYPE = 'invalid';
const CHOOSE_ORDER = [
  PREFERRED_DAEMON_TYPE,
  AGREGORE_TYPE,
  DAEMON_TYPE,
  WEB3_STORAGE_TYPE,
  ESTUARY_TYPE,
  READONLY_TYPE
];

class API {
  get type () {
    return INVALID_TYPE
  }

  async * get (url, { start, end, signal = null, format = null } = {}) {
    throw new Error('Not Implemented')
  }

  async getSize (url, signal = null) {
    throw new Error('Not Implemented')
  }

  async uploadCAR (carFileIterator, signal = null) {
    throw new Error('Not Implemented')
  }

  async uploadFile (carFileIterator, fileName, signal = null) {
    throw new Error('Not Implemented')
  }

  async clear (url, signal = null) {
    throw new Error('Not Implemented')
  }
}

async function detect ({
  daemonURL,
  web3StorageToken,
  web3StorageURL = WEB3_STORAGE_URL,
  estuaryToken,
  estuaryURL = ESTUARY_URL,
  publicGatewayURL = detectDefaultGateway(),
  readonly = true,
  timeout = DEFAULT_TIMEOUT,
  fetch = globalThis.fetch
} = {}) {
  const options = [];

  const toAttempt = [];

  toAttempt.push(
    detectAgregoreFetch(fetch)
      .then(detected => detected && options.push({ type: AGREGORE_TYPE, fetch }))
  );

  toAttempt.push(
    detectAllDaemons()
      .then(detected => detected && options.push({ type: DAEMON_TYPE, url: detected, fetch }))
  );

  if (daemonURL) {
    toAttempt.push(
      detectDaemon(daemonURL, timeout, fetch)
        .then(detected => detected && options.push({ type: PREFERRED_DAEMON_TYPE, url: daemonURL, fetch }))
    );
  }

  if (estuaryToken) {
    const url = estuaryURL;
    const authorization = estuaryToken;
    options.push({ type: ESTUARY_TYPE, url, authorization, fetch, publicGatewayURL });
  }

  if (web3StorageToken) {
    const url = web3StorageURL;
    const authorization = web3StorageToken;
    options.push({ type: WEB3_STORAGE_TYPE, url, authorization, fetch, publicGatewayURL });
  }

  if (readonly && publicGatewayURL) {
    options.push({ type: READONLY_TYPE, fetch, publicGatewayURL });
  }

  await Promise.allSettled(toAttempt);

  return options
}

async function create ({ chooseOrder = CHOOSE_ORDER, ...opts } = {}) {
  const options = await detect(opts);

  const chosen = defaultChoice(options, chooseOrder);

  return choose(chosen)
}

function defaultChoice (options, chooseOrder = CHOOSE_ORDER) {
  const sorted = options
    .filter(({ type }) => chooseOrder.includes(type))
    .sort(({ type: type1 }, { type: type2 }) => chooseOrder.indexOf(type1) - chooseOrder.indexOf(type2));

  const chosen = sorted[0];
  if (!chosen) throw new Error('Unable to find valid type')

  return chosen
}

async function choose (option) {
  const { type } = option;
  let api = null;
  if (type === AGREGORE_TYPE) {
    api = new AgregoreAPI(option.fetch || globalThis.fetch);
  } else if (type.startsWith(DAEMON_TYPE)) {
    api = new DaemonAPI(option.url);
  } else if (type === WEB3_STORAGE_TYPE) {
    api = new Web3StorageAPI(option.authorization, option.url, option.publicGatewayURL);
  } else if (type === ESTUARY_TYPE) {
    api = new EstuaryAPI(option.authorization, option.url, option.publicGatewayURL);
  } else if (type === READONLY_TYPE) {
    api = new ReadonlyGatewayAPI(option.publicGatewayURL);
  } else {
    throw new TypeError(`Unknown API type: ${type}.`)
  }

  return api
}

class ReadonlyGatewayAPI extends API {
  constructor (gatewayURL = detectDefaultGateway()) {
    super();
    this.gatewayURL = gatewayURL;
  }

  get type () {
    return READONLY_TYPE
  }

  async * get (url, { start, end, signal = null, format = null } = {}) {
    yield * getFromGateway({
      url,
      start,
      end,
      format,
      gatewayURL: this.gatewayURL,
      signal
    });
  }

  async getSize (url, signal = null) {
    const { cid, path, type } = parseIPFSURL(url);

    const relative = `/${type}/${cid}${path}`;
    const toFetch = new URL(relative, this.gatewayURL);

    return getSizeFromURL({
      url: toFetch,
      signal
    })
  }
}

class EstuaryAPI extends ReadonlyGatewayAPI {
  constructor (authorization, url = ESTUARY_URL, gatewayURL = detectDefaultGateway()) {
    super(gatewayURL);
    this.authorization = authorization;
    this.url = url;
  }

  get type () {
    return ESTUARY_TYPE
  }

  async uploadCAR (carFileIterator, signal = null) {
    throw new Error('Not Implemented')
  }

  async uploadFile (fileIterator, fileName, signal = null) {
    const toFetch = new URL('/content/add', this.url);
    toFetch.password = this.authorization;

    const response = await postFormFile({
      url: toFetch,
      file: fileIterator,
      fileName,
      parameterName: 'data',
      signal
    });

    const { cid } = await response.json();

    return `ipfs://${cid}/`
  }
}

class AgregoreAPI extends API {
  constructor (fetch = globalThis.fetch) {
    super();
    this.fetch = fetch;
  }

  get type () {
    return AGREGORE_TYPE
  }

  async * get (url, { start, end, signal = null, format = null } = {}) {
    const { fetch } = this;
    yield * getFromURL({
      url,
      start,
      end,
      format,
      fetch,
      signal
    });
  }

  async getSize (url, signal = null) {
    const { fetch } = this;
    return getSizeFromURL({
      url,
      fetch,
      signal
    })
  }

  async uploadCAR (carFileIterator, signal = null) {
    // convert to stream if iterator
    const body = await autoStream(carFileIterator);
    const { fetch } = this;
    const response = await fetch('ipfs://localhost', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/vnd.ipld.car'
      },
      signal,
      body
    });

    await checkError(response);

    const results = await response.text();

    return results.split('\n')
  }

  async uploadFile (fileIterator, signal = null) {
    const body = await autoStream(fileIterator);
    const { fetch } = this;
    const response = await fetch('ipfs://localhost', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/octet-stream'
      },
      signal,
      body
    });

    await checkError(response);

    return response.headers.get('Location')
  }
}

class Web3StorageAPI extends ReadonlyGatewayAPI {
  constructor (authorization, url = WEB3_STORAGE_URL, gatewayURL = detectDefaultGateway()) {
    super(gatewayURL);
    this.authorization = authorization;
    this.url = url;
  }

  get type () {
    return WEB3_STORAGE_TYPE
  }

  async uploadCAR (carFileIterator, signal = null) {
    const toFetch = new URL('/car', this.url);
    toFetch.password = this.authorization;

    const response = await postRawBody({
      url: toFetch,
      fileIterator: carFileIterator,
      signal
    });

    const contents = await response.text();
    const items = contents.split('\n');

    return items.filter((line) => line).map((line) => {
      const { cid } = JSON.parse(line);
      return `ipfs://${cid}/`
    })
  }

  async uploadFile (fileIterator, { fileName = '', signal = null } = {}) {
    const toFetch = new URL('/upload', this.url);
    toFetch.password = this.authorization;

    const response = await postFormFile({
      url: toFetch,
      file: fileIterator,
      fileName,
      signal
    });

    const { cid } = await response.json();

    return `ipfs://${cid}/`
  }
}

class DaemonAPI extends API {
  constructor (url = DEFAULT_DAEMON_API_URL) {
    super();
    this.url = url;
  }

  get type () {
    return DAEMON_TYPE
  }

  async * getFile (url, { start, end, signal = null, format = null } = {}) {
    const { cid, path, type } = parseIPFSURL(url);
    const relative = `/api/v0/cat?arg=/${type}/${cid}${path}`;
    const toFetch = new URL(relative, this.url);

    if (start) {
      toFetch.searchParams.set('offset', start);
    }
    if (end) {
      toFetch.searchParams.set('length', end - (start || 0) + 1);
    }

    if (format) {
      throw new Error('Format is unsupported on Kubo Daemons for now')
    }

    const response = await fetch(toFetch, {
      method: 'POST',
      signal
    });

    await checkError(response);

    yield * streamToIterator(response.body);
  }

  async * getRaw (url, { signal = null } = {}) {
    const { cid, path, type } = parseIPFSURL(url);
    const relative = `/api/v0/block/get?arg=/${type}/${cid}${path}`;
    const toFetch = new URL(relative, this.url);

    const response = await fetch(toFetch, {
      method: 'POST',
      signal
    });

    await checkError(response);

    yield * streamToIterator(response.body);
  }

  async * getCar (url, { signal = null } = {}) {
    const { cid, path, type } = parseIPFSURL(url);
    const relative = `/api/v0/dag/export?arg=/${type}/${cid}${path}`;
    const toFetch = new URL(relative, this.url);

    const response = await fetch(toFetch, {
      method: 'POST',
      signal
    });

    await checkError(response);

    yield * streamToIterator(response.body);
  }

  async * get (url, { start, end, signal = null, format = null } = {}) {
    if (format) {
      if (format === 'raw') {
        yield * this.getRaw(url, { start, end, signal });
      } else if (format === 'car') {
        yield * this.getCar(url, { start, end, signal });
      } else {
        throw new Error(`Invalid format type, must be car or 'raw', got ${format}`)
      }
    }
    yield * this.getFile(url, { start, end, signal });
  }

  async getSize (url, signal = null) {
    try {
      const { cid, path, type } = parseIPFSURL(url);
      const relative = `/api/v0/file/ls?arg=/${type}/${cid}${path}&size=true`;
      const toFetch = new URL(relative, this.url);

      const response = await fetch(toFetch, {
        method: 'POST',
        signal
      });

      await checkError(response);

      const { Objects } = await response.json();

      const [{ Size }] = Object.values(Objects);

      return Size
    } catch (e) {
      if (debug) console.warn(e);
      return this._getSizeWithDag(url, signal)
    }
  }

  async _getSizeWithDag (url, signal = null) {
    const { cid, path, type } = parseIPFSURL(url);
    const relative = `/api/v0/dag/stat?arg=/${type}/${cid}${path}`;
    const toFetch = new URL(relative, this.url);

    const response = await fetch(toFetch, {
      method: 'POST',
      signal
    });

    await checkError(response);

    const { Size } = await response.json();

    return parseInt(Size, 10)
  }

  async _pin (url, signal = null) {
    const { cid, path, type } = parseIPFSURL(url);
    const relative = `/api/v0/pin/add?arg=/${type}/${cid}${path}`;
    const toFetch = new URL(relative, this.url);

    const response = await fetch(toFetch, {
      method: 'POST',
      signal
    });

    await checkError(response);
  }

  async _unpin (url, signal = null) {
    const { cid, path, type } = parseIPFSURL(url);
    const relative = `/api/v0/pin/rm?arg=/${type}/${cid}${path}`;
    const toFetch = new URL(relative, this.url);

    const response = await fetch(toFetch, {
      method: 'POST',
      signal
    });

    await checkError(response);
  }

  async clear (url, signal = null) {
    return this._unpin(url, signal)
  }

  async uploadCAR (carFileIterator, signal = null) {
    const relative = '/api/v0/dag/import?allow-big-block=true&pin-roots=true';
    const toFetch = new URL(relative, this.url);

    const response = await postFormFile({
      url: toFetch,
      file: carFileIterator,
      signal
    });

    const contents = await response.text();
    const items = contents.split('\n');

    return items.filter((line) => line).map((line) => {
      const { Root } = JSON.parse(line);
      const cid = Root.Cid['/'];
      return `ipfs://${cid}/`
    })
  }

  async uploadFile (fileIterator, fileName = '', signal = null) {
    const relative = '/api/v0/add?pin=true&cid-version=1&inline=false&raw-leaves=true';
    const toFetch = new URL(relative, this.url);

    const isFile = fileIterator.name && fileIterator instanceof Blob;
    // We should just wrap files or things with a name with a directory
    if (fileName || isFile) {
      toFetch.searchParams.set('wrap-with-directory', 'true');
    }

    const response = await postFormFile({
      url: toFetch,
      file: fileIterator,
      fileName,
      signal
    });

    const contents = await response.text();
    const [line] = contents.split('\n');

    const { Hash: cid } = JSON.parse(line);

    const url = `ipfs://${cid}/`;

    await this._pin(url, signal);

    return url
  }
}

exports.hasInterceptedWebRequests = false;
const shouldInterceptWebRequests = !!(
  globalThis &&
  globalThis.chrome &&
  globalThis.chrome.webRequest &&
  globalThis.chrome.webRequest.onBeforeSendHeaders &&
  globalThis.chrome.webRequest.onBeforeSendHeaders.addListener
);

async function detectAllDaemons () {
  const potentialGateways = KNOWN_DAEMON_PORTS.map((port) => `http://localhost:${port}`);
  try {
    // Search all the potential gateways in parallel and return the first valid one
    const foundGateway = await Promise.any(potentialGateways.map(
      (gateway) => detectDaemon(gateway).then((exists) => {
        if (exists) return gateway
        throw new Error('Not found')
      })
    ));

    if (!foundGateway) return false

    if (shouldInterceptWebRequests && !exports.hasInterceptedWebRequests) {
      interceptWebRequests(foundGateway);
    }

    return foundGateway
  } catch {
    return false
  }
}

// This a funky thing that WebRecorder did to bypass cors
function interceptWebRequests (apiURL) {
  exports.hasInterceptedWebRequests = true;
  globalThis.chrome.webRequest.onBeforeSendHeaders.addListener((details) => {
    const { requestHeaders } = details;

    for (const header of requestHeaders) {
      if (header.name.toLowerCase() === 'origin') {
        header.value = apiURL;
        return { requestHeaders }
      }
    }

    details.requestHeaders.push({ name: 'Origin', value: apiURL });
    return { requestHeaders }
  },
  { urls: [apiURL + '/*'] },
  ['blocking', 'requestHeaders', 'extraHeaders']
  );
}

async function detectAgregoreFetch (fetch = globalThis.fetch) {
  try {
    // Should throw error if IPFS is not supported
    // Also throws an error in brave even with IPFS support
    await fetch('ipfs://localhost/');
    return true
  } catch (e) {
    if (debug) console.warn('Unable to detect Agregore', e);
    return false
  }
}

async function detectDaemon (url = DEFAULT_DAEMON_API_URL, timeout = 1000, fetch = globalThis.fetch) {
  try {
    const controller = new AbortController();
    const { signal } = controller;
    setTimeout(() => controller.abort(), timeout);
    const response = await fetch(new URL('/api/v0/version', url), {
      method: 'POST', signal
    });
    if (response.ok) return true
    if (response.status && response.status !== 404) return true
    return false
  } catch (e) {
    if (debug) console.warn('Unable to detect Kubo Daemon', e, url);
    return false
  }
}

exports.AGREGORE_TYPE = AGREGORE_TYPE;
exports.API = API;
exports.AgregoreAPI = AgregoreAPI;
exports.CHOOSE_ORDER = CHOOSE_ORDER;
exports.DAEMON_TYPE = DAEMON_TYPE;
exports.DEFAULT_DAEMON_API_URL = DEFAULT_DAEMON_API_URL;
exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
exports.DaemonAPI = DaemonAPI;
exports.ESTUARY_TYPE = ESTUARY_TYPE;
exports.ESTUARY_URL = ESTUARY_URL;
exports.EstuaryAPI = EstuaryAPI;
exports.INVALID_TYPE = INVALID_TYPE;
exports.KNOWN_DAEMON_PORTS = KNOWN_DAEMON_PORTS;
exports.PREFERRED_DAEMON_TYPE = PREFERRED_DAEMON_TYPE;
exports.READONLY_TYPE = READONLY_TYPE;
exports.ReadonlyGatewayAPI = ReadonlyGatewayAPI;
exports.W3S_LINK_URL = W3S_LINK_URL;
exports.WEB3_STORAGE_TYPE = WEB3_STORAGE_TYPE;
exports.WEB3_STORAGE_URL = WEB3_STORAGE_URL;
exports.Web3StorageAPI = Web3StorageAPI;
exports.choose = choose;
exports.create = create;
exports.defaultChoice = defaultChoice;
exports.detect = detect;
exports.detectAgregoreFetch = detectAgregoreFetch;
exports.detectAllDaemons = detectAllDaemons;
exports.detectDaemon = detectDaemon;
exports.detectDefaultGateway = detectDefaultGateway;
exports.setDebug = setDebug;
exports.shouldInterceptWebRequests = shouldInterceptWebRequests;
exports.toGatewayURL = toGatewayURL;
