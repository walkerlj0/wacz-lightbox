const escapeRegexChars = [
    '-',
    '[',
    ']',
    '/',
    '{',
    '}',
    '(',
    ')',
    '*',
    '+',
    '?',
    '.',
    '\\',
    '^',
    '$',
    '|',
];
const escapeRegexPattern = new RegExp(`[${escapeRegexChars.join('\\')}]`, 'g');
const escapeRegex = (str) => str.replace(escapeRegexPattern, '\\$&');
/**
 * Renders a string with keywords highlighted
 */
export class KeywordMarkElement extends HTMLElement {
    /** constructor */
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
    }
    /** @inheritdoc */
    static get observedAttributes() {
        return ['keywords', 'delimiter'];
    }
    /**
     * Keywords to highlight
     */
    get keywords() {
        var _a;
        return (_a = this.getAttribute('keywords')) !== null && _a !== void 0 ? _a : '';
    }
    /**
     * Sets the keywords to highlight
     * @param {string} val keywords to set
     */
    set keywords(val) {
        this.setAttribute('keywords', val);
    }
    /**
     * Delimiter for keywords
     */
    get delimiter() {
        var _a;
        return (_a = this.getAttribute('delimiter')) !== null && _a !== void 0 ? _a : '';
    }
    /**
     * Sets delimiter for keywords
     * @param {string} val delimiter to set
     */
    set delimiter(val) {
        this.setAttribute('delimiter', val);
    }
    /** @inheritdoc */
    attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'keywords' || name === 'delimiter') {
            if (newValue !== oldValue) {
                this._render();
            }
        }
    }
    /** @inheritdoc */
    connectedCallback() {
        this._render();
        this.__observer = new MutationObserver(() => {
            this._render();
        });
        this.__observer.observe(this, {
            childList: true,
            characterData: true,
            subtree: true,
        });
    }
    /** @inheritdoc */
    disconnectedCallback() {
        if (this.__observer) {
            this.__observer.disconnect();
            this.__observer = undefined;
        }
    }
    /**
     * Renders the current string with keywords highlighted
     */
    _render() {
        if (!this.shadowRoot) {
            return;
        }
        const text = this.textContent || '';
        const keywords = this.getAttribute('keywords');
        const delimiter = this.getAttribute('delimiter') || /\s+/;
        if (!keywords) {
            this.shadowRoot.textContent = text;
            return;
        }
        const lowerText = text.toLowerCase();
        const terms = keywords
            .toLowerCase()
            .split(delimiter)
            .sort((a, b) => {
            return b.length - a.length;
        });
        const splitPattern = new RegExp(`${terms.map(escapeRegex).join('|')}`, 'gi');
        const parts = text.split(splitPattern);
        const result = document.createElement('div');
        let cursor = 0;
        for (const part of parts) {
            result.appendChild(document.createTextNode(part));
            cursor += part.length;
            if (cursor < lowerText.length) {
                const slice = lowerText.substring(cursor);
                const match = terms.find((t) => slice.startsWith(t));
                if (match) {
                    const mark = document.createElement('mark');
                    mark.textContent = text.substr(cursor, match.length);
                    result.appendChild(mark);
                    cursor += match.length;
                }
            }
        }
        this.shadowRoot.innerHTML = `
      <style>
        mark {
          color: var(--keyword-mark-color);
          background: var(--keyword-mark-background, yellow);
        }
      </style>
      ${result.innerHTML}
    `;
    }
}
customElements.define('keyword-mark', KeywordMarkElement);
//# sourceMappingURL=keyword-mark.js.map